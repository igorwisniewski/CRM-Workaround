generator client {
  provider      = "prisma-client-js"
  // Dodajemy binaryTargets, aby zbudować klienta pod Windows (dev) i Linux (prod)
  // "rhel-openssl-1.0.x" lub "rhel-openssl-3.0.x" to standard dla CloudLinux (Seohost)
  // "debian-openssl-1.1.x" to bezpieczny fallback
  binaryTargets = ["native", "rhel-openssl-1.0.x", "rhel-openssl-3.0.x", "linux-musl-openssl-3.0.x", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  ADMIN
}

model User {
  id       String  @id @default(uuid())
  email    String  @unique
  password String
  role     Role    @default(USER)
  kolor    String?

  createdContacts  Contact[] @relation("CreatedBy")
  assignedContacts Contact[] @relation("AssignedTo")
  createdTasks     Task[]    @relation("TaskCreatedBy")
  assignedTasks    Task[]    @relation("TaskAssignedTo")
}

model Contact {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  imie              String
  etap              String
  email             String?
  telefon           String?
  zrodlo            String?
  branza            String?
  opis              String? @db.Text
  procesy           Json? // Tu będzie lista: [{nazwa: "X", kwota: 100}, ...]
  wartosc           Float?  @default(0) // Suma kwot z procesów
  czyWystawilOpinie Boolean @default(false) // Checkboxnpx prisma db push

  nazwaFirmy              String?
  rodzajDzialki           String?
  potrzebaKlienta         String? @db.Text
  formaOpodatkowania      String?
  zobowiazania            Json?
  majatekFirmy            String? @db.Text
  czyZatrudniaPracownikow String?
  opoznieniaWPlatnosciach String?
  planNaRozwoj            String? @db.Text
  stanCywilny             String?
  rozdzielnoscMajatkowa   String?
  majatekPrywatny         String? @db.Text
  czyBralKredyt10Lat      String?

  createdById  String
  createdBy    User   @relation("CreatedBy", fields: [createdById], references: [id])
  assignedToId String
  assignedTo   User   @relation("AssignedTo", fields: [assignedToId], references: [id])

  tasks Task[]
}

model Task {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  nazwa    String
  opis     String?  @db.Text
  termin   DateTime
  wykonane Boolean  @default(false)

  contactId String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  createdById String
  createdBy   User   @relation("TaskCreatedBy", fields: [createdById], references: [id])

  assignedToId String
  assignedTo   User   @relation("TaskAssignedTo", fields: [assignedToId], references: [id])
}
